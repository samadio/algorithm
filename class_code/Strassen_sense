we dont want to construct new matrixes, so we
 work with blocks as indexes

strassen_aux() recursive implementation: if matrix_dim<2,stop the recursion->naive_aux

C1X= top left of the new splitted blocks, CX1 top right,ecc...  n is block size, then iteratively we split more->n2=n/2

line 99: Now we construct the new matrixes: 10 S matrixes and seven P matrixes and at the end we will deallocate_matrix

first equation: S1=B12-B22
we sub_matrix_blocks and give the two new matrixes defined by B, B1X,BX2,B B2X,BX2,n2. And so on with S and P and lastly update C.

allocate_matrix(nrow,ncol) and deallocate_matrix are in matrix.c

Why does the first code goes slower than naive? Asyntothic complexity does not resemble the behaviour of every implementation: if the implementation of Strassen is unefficient, doesn't matter the algorithm complexity...

PROBLEMS:
	1) we use Strassen even for 2x2 blocks. Is it worth it?
	   It's sufficient to define by hand C[1][1]= A[1][1]xB[1][1]+A[1][2]x B[2][1] and so on
	   this would take only 4 sums and 8 multi, while in strassen we have 18 sums and 7 multiplications->Change basis case
	   
HOMEWORK: change implementation of Strassen Algorithm in order to improve it (add a 3rd column hoping it will be better).
	Hints: we keep allocating and deallocating in every recursion, avoid it
